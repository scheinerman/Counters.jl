var documenterSearchIndex = {"docs":
[{"location":"#Counters","page":"Counters","title":"Counters","text":"","category":"section"},{"location":"#Overview","page":"Counters","title":"Overview","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"We often want to count things and a way to do that is to create a dictionary that maps objects to their counts. A Counter object simplifies that process. Say we want to count values of type String. We would create a counter for that type like this:","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> c = Counter{String}()\nCounter{String} with 0 entries","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"The two primary operations for a Counter are value increment and value retrieval. To increment the value of a counter we do this:","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> c[\"hello\"] += 1\n1","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"To access the count, we use square brackets:","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> c[\"hello\"]\n1\n\njulia> c[\"bye\"]\n0","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"Notice that we need not worry about whether or not a key is already known to the Counter. If presented with an unknown key, the Counter assumes its value is 0.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"A Counter may be assigned to like this c[\"alpha\"]=4 but the more likely use case is c[\"bravo\"]+=1 invoked each time a value, such as \"bravo\" is encountered.","category":"page"},{"location":"#Counting-the-elements-of-a-list","page":"Counters","title":"Counting the elements of a list","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"The function counter (lowercase 'c') counts the element of a list/array or set. The multiplicity of an element is the number of times it appears in the list.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> A = [ \"alpha\", \"bravo\", \"alpha\", \"gamma\" ];\n\njulia> C = counter(A);\n\njulia> C\nCounter{String} with these nonzero values:\nalpha ==> 2\nbravo ==> 1\ngamma ==> 1","category":"page"},{"location":"#Addition-of-counters","page":"Counters","title":"Addition of counters","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"If c and d are counters (of the same type of object) their sum c+d creates a new counter by adding the values in c and d. That is, if a=c+d and k is any key, then a[k] equals c[k]+d[k].","category":"page"},{"location":"#Incrementing","page":"Counters","title":"Incrementing","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"To increment the count of an item x in a counter c we may either use c[x]+=1 or the increment function like this: incr!(c,x).","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"The increment function incr! is more useful for incrementing a collection of items. Use incr!(c,items) to add 1 to the count for each element held in items. If an element is present in items multiple times, its count is incremented for each occurrence.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> c = Counter{Int}()\nCounter{Int64} with 0 entries\n\njulia> items = [1,2,3,4,1,2,1]\n7-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n 1\n 2\n 1\n\njulia> incr!(c,items)\n\njulia> c\nCounter{Int64} with these nonzero values:\n1 ==> 3\n2 ==> 2\n3 ==> 1\n4 ==> 1","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"In addition, incr! may be used to increment one counter by the amount held in another. Note that it's the first argument c that gets changed; there is no effect on the second argument d.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"Note: incr!(c,d) and c += d have the same effect, but the first is more efficient.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> c = Counter{Int}()\nCounter{Int64} with these nonzero values:\n\njulia> items = [1,2,3,4,1,2,1]\n7-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 1\n 2\n 1\n\njulia> incr!(c,items)\n\njulia> c\nCounter{Int64} with these nonzero values:\n1 ==> 3\n2 ==> 2\n3 ==> 1\n4 ==> 1","category":"page"},{"location":"#More-functions","page":"Counters","title":"More functions","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"sum(c) returns the sum of the values in c; that is, the total","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"of all the counts.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"length(c) returns the number of values held in c. Note that","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"this might include objects with value 0.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"nnz(c) returns the number of nonzero values held","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"in c.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"keys(c) returns an iterator for the keys held by c.\nvalues(c) returns an iterator for the values held by c.\ndisplay(c) gives a print out of all the keys and their nonzero","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"values in c.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"clean!(c) removes all keys from c whose value is 0. This","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"won't change its behavior, but will free up some memory.","category":"page"},{"location":"#Listing-elements","page":"Counters","title":"Listing elements","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"We can convert a Counter into a one-dimensional array in which each element appears with its appropriate multiplicity using collect:","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> C = Counter{Int}()\nCounter{Int64} with 0 entries\n\njulia> C[3] = 4\n4\n\njulia> C[5] = 0\n0\n\njulia> C[-2] = 2\n2\n\njulia> collect(C)\n6-element Array{Int64,1}:\n  3\n  3\n  3\n  3\n -2\n -2\n","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"The function collect_by_counts lists the elements of a Counter once each,  but in decreasing order of their counts. That is, the element with the highest count is first, the element with the second highest count is second, and so forth.  Elements whose count is zero are not listed.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> collect_by_counts(C)\n2-element Vector{Int64}:\n  3\n -2","category":"page"},{"location":"#Average-value","page":"Counters","title":"Average value","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"If the objects counted in C are numbers, then we compute the weighted average of those numbers with mean(C).","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> C = Counter{Int}()\nCounter{Int64} with 0 entries\n\njulia> C[2] = 3\n3\n\njulia> C[3] = 7\n7\n\njulia> mean(C)\n2.7","category":"page"},{"location":"#Hashing","page":"Counters","title":"Hashing","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"hash(C::Counter) returns a hash value for the C. Note that clean! is applied to C before computing the hash. This is done to ensure that equal counters give the same hash value.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"May also be invoked as hash(C::Counter, h::Uint).","category":"page"},{"location":"#It's-Associative","page":"Counters","title":"It's Associative","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"A Counter is a subtype of Associative and therefore we can use methods such as keys and/or values to get iterators to those items.","category":"page"},{"location":"#CSV-Printing","page":"Counters","title":"CSV Printing","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"The function csv_print writes a Counter to the screen in comma-separated format. This can be readily used for importing into a spreadsheet.","category":"page"},{"location":"","page":"Counters","title":"Counters","text":"julia> C = Counter{Float64}()\nCounter{Float64} with 0 entries\n\njulia> C[3.4]=10\n10\n\njulia> C[2.2]=3\n3\n\njulia> csv_print(C)\n2.2, 3\n3.4, 10","category":"page"},{"location":"#Counting-in-parallel","page":"Counters","title":"Counting in parallel","text":"","category":"section"},{"location":"","page":"Counters","title":"Counters","text":"See the parallel-example directory for an illustration of how to use Counters in multiple parallel processes.","category":"page"}]
}
